#include <iostream>
#include <string>
#include <cstdint>
#include <cmath>

using namespace std;

class Rational
{
private:
    int64_t num;    // числитель
    uint64_t den;   // знаменатель

    // Функция для нахождения наибольшего общего делителя
    int64_t findGCD(int64_t a, int64_t b)
    {
        a = abs(a);
        b = abs(b);
        while (b != 0)
        {
            int64_t temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }

    // Функция для сокращения дроби
    void reduceFraction()
    {
        if (num == 0)
        {
            den = 1;
            return;
        }
        
        int64_t gcd = findGCD(num, den);
        num = num / gcd;
        den = den / gcd;
        
        // Убедимся, что знаменатель всегда положительный
        if (den < 0)
        {
            den = -den;
            num = -num;
        }
    }

public:
    // Конструктор без аргументов (дробь 0/1)
    Rational()
    {
        num = 0;
        den = 1;
    }

    // Конструктор от целого числа
    Rational(int64_t wholeNumber)
    {
        num = wholeNumber;
        den = 1;
    }

    // Конструктор от числителя и знаменателя
    Rational(int64_t numerator, int64_t denominator)
    {
        if (denominator == 0)
        {
            // Ошибка - деление на ноль, но по условию обработка не требуется
            // Сделаем знаменатель = 1 чтобы избежать проблем
            num = numerator;
            den = 1;
        }
        else
        {
            num = numerator;
            den = denominator;
            reduceFraction();
        }
    }

    // Получить числитель
    int64_t numerator()
    {
        return num;
    }

    // Получить знаменатель
    uint64_t denominator()
    {
        return den;
    }

    // Явное приведение к double
    explicit operator double()
    {
        return static_cast<double>(num) / static_cast<double>(den);
    }

    // Перевод в строку
    string str()
    {
        if (den == 1)
        {
            return to_string(num);
        }
        else
        {
            return to_string(num) + "/" + to_string(den);
        }
    }

    // Сложение
    Rational operator+(const Rational& other)
    {
        int64_t new_num = num * other.den + other.num * den;
        uint64_t new_den = den * other.den;
        return Rational(new_num, new_den);
    }

    Rational operator+=(const Rational& other)
    {
        *this = *this + other;
        return *this;
    }

    // Вычитание
    Rational operator-(const Rational& other)
    {
        int64_t new_num = num * other.den - other.num * den;
        uint64_t new_den = den * other.den;
        return Rational(new_num, new_den);
    }

    Rational operator-=(const Rational& other)
    {
        *this = *this - other;
        return *this;
    }

    // Умножение
    Rational operator*(const Rational& other)
    {
        int64_t new_num = num * other.num;
        uint64_t new_den = den * other.den;
        return Rational(new_num, new_den);
    }

    Rational operator*=(const Rational& other)
    {
        *this = *this * other;
        return *this;
    }

    // Деление
    Rational operator/(const Rational& other)
    {
        int64_t new_num = num * other.den;
        uint64_t new_den = den * other.num;
        return Rational(new_num, new_den);
    }

    Rational operator/=(const Rational& other)
    {
        *this = *this / other;
        return *this;
    }

    // Унарный минус
    Rational operator-()
    {
        return Rational(-num, den);
    }

    // Операции сравнения
    bool operator==(const Rational& other)
    {
        return (num == other.num) && (den == other.den);
    }

    bool operator!=(const Rational& other)
    {
        return !(*this == other);
    }

    bool operator<(const Rational& other)
    {
        return (num * other.den) < (other.num * den);
    }

    bool operator<=(const Rational& other)
    {
        return (*this < other) || (*this == other);
    }

    bool operator>(const Rational& other)
    {
        return !(*this <= other);
    }

    bool operator>=(const Rational& other)
    {
        return !(*this < other);
    }
};

// Функция для демонстрации работы
int main()
{
    // Тестирование конструкторов
    Rational r1; // по умолчанию
    Rational r2(5); // от целого числа
    Rational r3(6, 8); // от числителя и знаменателя (должно сократиться до 3/4)
    Rational r4(-2, 4); // отрицательная дробь (должно сократиться до -1/2)
    Rational r5(4, -8); // отрицательный знаменатель (должно стать -1/2)

    cout << "r1: " << r1.str() << endl;
    cout << "r2: " << r2.str() << endl;
    cout << "r3: " << r3.str() << endl;
    cout << "r4: " << r4.str() << endl;
    cout << "r5: " << r5.str() << endl;

    // Тестирование арифметических операций
    Rational sum = r2 + r3; // 5 + 3/4 = 23/4
    cout << "5 + 3/4 = " << sum.str() << endl;

    Rational diff = r2 - r3; // 5 - 3/4 = 17/4
    cout << "5 - 3/4 = " << diff.str() << endl;

    Rational mult = r3 * r4; // 3/4 * (-1/2) = -3/8
    cout << "3/4 * (-1/2) = " << mult.str() << endl;

    Rational div = r2 / r3; // 5 / (3/4) = 20/3
    cout << "5 / (3/4) = " << div.str() << endl;

    // Тестирование унарного минуса
    Rational neg = -r3;
    cout << "-(3/4) = " << neg.str() << endl;

    // Тестирование сравнения
    cout << "3/4 == 6/8? " << (r3 == Rational(6, 8)) << endl;
    cout << "3/4 < 1? " << (r3 < Rational(1)) << endl;
    cout << "3/4 > 1/2? " << (r3 > Rational(1, 2)) << endl;

    // Тестирование приведения к double
    double decimal = static_cast<double>(r3);
    cout << "3/4 как double: " << decimal << endl;

    // Тестирование составных операций
    Rational r6(1, 2);
    r6 += Rational(1, 3); // 1/2 + 1/3 = 5/6
    cout << "1/2 + 1/3 = " << r6.str() << endl;

    return 0;
}
