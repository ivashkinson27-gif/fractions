#include <iostream>
#include <numeric>
#include <string>
#include <cmath>
#include <stdexcept>

class R {
private:
    int64_t n;
    uint64_t d;

    void r() {
        if (d == 0) {
            throw std::runtime_error("D cannot be zero.");
        }
        auto g = std::gcd(static_cast<uint64_t>(std::abs(n)), d);
        n /= static_cast<int64_t>(g);
        d /= g;
    }

public:
    R() : n(0), d(1) {}

    explicit R(int64_t x) : n(x), d(1) {}

    R(int64_t num, int64_t den) {
        if (den == 0) {
            throw std::invalid_argument("D cannot be zero.");
        }
        if (den < 0) {
            n = -num;
            d = static_cast<uint64_t>(-den);
        } else {
            n = num;
            d = static_cast<uint64_t>(den);
        }
        r();
    }

    int64_t numerator() const { return n; }
    uint64_t denominator() const { return d; }

    explicit operator double() const {
        return static_cast<double>(n) / static_cast<double>(d);
    }

    std::string str() const {
        return std::to_string(n) + "/" + std::to_string(d);
    }

    R& operator+=(const R& o) {
        uint64_t nd = d * o.d;
        int64_t nn = n * static_cast<int64_t>(o.d) + o.n * static_cast<int64_t>(d);
        n = nn;
        d = nd; 
        r();
        return *this;
    }

    R& operator-=(const R& o) {
        *this += (-o);
        return *this;
    }

    R& operator*=(const R& o) {
        n *= o.n;
        d *= o.d; 
        r();
        return *this;
    }

    R& operator/=(const R& o) {
        if (o.n == 0) {
            throw std::domain_error("Division by zero.");
        }
        
        int64_t nn = n * static_cast<int64_t>(o.d);
        uint64_t nd = d * static_cast<uint64_t>(std::abs(o.n));

        if (o.n < 0) {
            nn = -nn;
        }

        n = nn;
        d = nd;

        r();
        return *this;
    }

    R operator-() const {
        return R(-n, static_cast<int64_t>(d));
    }
    
    bool operator==(const R& o) const {
        return n == o.n && d == o.d;
    }

    bool operator!=(const R& o) const {
        return !(*this == o);
    }
    
    bool operator<(const R& o) const {
        return static_cast<long double>(n) * o.d < static_cast<long double>(o.n) * d;
    }

    bool operator<=(const R& o) const {
        return (*this < o) || (*this == o);
    }

    bool operator>(const R& o) const {
        return o < *this;
    }

    bool operator>=(const R& o) const {
        return !(*this < o);
    }
};

R operator+(R l, const R& r) { l += r; return l; }
R operator-(R l, const R& r) { l -= r; return l; }
R operator*(R l, const R& r) { l *= r; return l; }
R operator/(R l, const R& r) { l /= r; return l; }

int main() {
    R r1(3, 6);
    R r2(-1, 3);
    R r3 = r1 + r2; 
    R r4(5);

    std::cout << "r1: " << r1.str() << std::endl;
    std::cout << "r2: " << r2.str() << std::endl;
    std::cout << "r1 + r2: " << r3.str() << std::endl;
    std::cout << "r4 * r1: " << (r4 * r1).str() << std::endl;
    
    std::cout << "r1 < r2: " << (r1 < r2) << std::endl;

    return 0;
}
